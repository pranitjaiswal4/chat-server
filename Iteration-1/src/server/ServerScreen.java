/** Pranit Jaiswal
 * (ID: pxj6023) */
package server;

import java.awt.Color;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import utils.CSVReaderInJava;
import utils.Constants;
import utils.Utils;

//  Class to implement Server along with ClientHandler and Server GUI
//  Reference URL : http://www.srikanthtechnologies.com/blog/java/chatdemo.aspx
public class ServerScreen extends javax.swing.JFrame {

    ServerSocket server;
    Vector<String> users = new Vector<String>();                                // Vector to keep track of all users
    Vector<HandleClient> clients = new Vector<HandleClient>();                  // Vector to keep track of connected clients

    String MESSAGE = "";                                                        // PROCESSED MESSAGE TO SEND
    public String MESSAGE_TYPE = "Multicast";                                   // MESSAGE_TYPE : Unicast/Multicast/Broadcast
    public String UNICAST_USERNAME = "";
    public String MULTICAST_USERLIST = "";                                      // For collecting users for multicasting
    public ArrayList<String> MULTICAST_USERNAMES = new ArrayList<String>();     // For storing users in list for multicasting

    /**
     * Creates new form ServerScreen
     */
    public ServerScreen() {
        customizeFrame();       // Customize Frame before making it visible
        initComponents();       // Initialize all components of the Frame
        refreshListOfUsers();   // Get the user data available to show on server screen
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel3 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        userListScrollPane = new javax.swing.JScrollPane();
        jPanel1 = new javax.swing.JPanel();
        username_ta = new javax.swing.JTextArea();
        status_ta = new javax.swing.JTextArea();
        timestamp_ta = new javax.swing.JTextArea();
        close_server_btn = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setResizable(false);

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        jLabel1.setText("Username");

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        jLabel2.setText("Online Status");

        jLabel4.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        jLabel4.setText("Recent Log-in");

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(24, 24, 24)
                .addComponent(jLabel1)
                .addGap(72, 72, 72)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel4)
                .addGap(22, 22, 22))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jLabel2)
                    .addComponent(jLabel4))
                .addGap(0, 0, Short.MAX_VALUE))
        );

        userListScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        username_ta.setEditable(false);
        username_ta.setColumns(20);
        username_ta.setFont(new java.awt.Font("Monospaced", 0, 14)); // NOI18N
        username_ta.setRows(50);
        username_ta.setFocusable(false);
        username_ta.setMargin(new java.awt.Insets(5, 10, 5, 10));

        status_ta.setEditable(false);
        status_ta.setColumns(20);
        status_ta.setFont(new java.awt.Font("Monospaced", 0, 14)); // NOI18N
        status_ta.setRows(5);
        status_ta.setFocusable(false);
        status_ta.setMargin(new java.awt.Insets(5, 10, 5, 10));

        timestamp_ta.setEditable(false);
        timestamp_ta.setColumns(20);
        timestamp_ta.setFont(new java.awt.Font("Monospaced", 0, 14)); // NOI18N
        timestamp_ta.setRows(5);
        timestamp_ta.setFocusable(false);
        timestamp_ta.setMargin(new java.awt.Insets(5, 10, 5, 10));

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(username_ta, javax.swing.GroupLayout.PREFERRED_SIZE, 118, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(status_ta, javax.swing.GroupLayout.PREFERRED_SIZE, 135, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(timestamp_ta, javax.swing.GroupLayout.DEFAULT_SIZE, 224, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(timestamp_ta, javax.swing.GroupLayout.PREFERRED_SIZE, 727, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(status_ta)
                    .addComponent(username_ta, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                .addContainerGap())
        );

        userListScrollPane.setViewportView(jPanel1);

        close_server_btn.setBackground(new java.awt.Color(153, 0, 0));
        close_server_btn.setForeground(new java.awt.Color(255, 255, 255));
        close_server_btn.setText("Close Server");
        close_server_btn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                close_server_btnActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(close_server_btn))
                    .addComponent(userListScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 548, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(close_server_btn, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(24, 24, 24)
                        .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(userListScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 707, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    // Method to call when user clicks on close server button
    private void close_server_btnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_close_server_btnActionPerformed
        // TODO add your handling code here:
        System.out.println("Clicked on close server");
        broadcastToCloseAllConnectedClients();      // Send broadcast to close all the connected clients
        JOptionPane.showMessageDialog(null, "Server closed successfully", "Done", JOptionPane.INFORMATION_MESSAGE);     // Show dialog for Server Close
        closeServer();                              // Close the server
        System.out.println("Server Closed...");     // Print message Close Server
        terminateWindow();                          // Terminate the server window
    }//GEN-LAST:event_close_server_btnActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ServerScreen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ServerScreen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ServerScreen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ServerScreen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        ServerScreen mServerScreen = new ServerScreen();        // Initialize ServerScreen object

        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                mServerScreen.setVisible(true);                 // Make server screen visible
            }
        });

        Utils.createFilePathForUsernames();                     // Create a csv file to maintain users even when the session is terminated

        mServerScreen.startServer();                            // Start server process

    }

    // Method to customize the frame before making it visible
    private void customizeFrame() {
        setTitle("Server");                                                 // Set title of the frame
        getContentPane().setBackground(new java.awt.Color(255, 255, 255));  // Set background color of the frame

        // Window listener to perform any window related operations
        addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {

            }
        });
    }

    // Method to terminate the window
    private void terminateWindow() {
        System.exit(0);
    }

    // Method to close Server
    private void closeServer() {
        if (server != null && !server.isClosed()) {
            try {
                server.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    // Method to start Server
    private void startServer() {
        try {
            server = new ServerSocket(Constants.PORT_NUMBER, 10);               // Initialize the Server Socket with port number
            System.out.println("Server Started...");                            // Print message server started

            while (true) {
                if (server != null && !server.isClosed()) {                     // Condition check for server connnectivity

                    Socket client = server.accept();                            // Create socket for client connection
                    HandleClient c = new HandleClient(client);                  // Add the socket to the defined client handler
                    clients.add(c);                                             // Add the client to the connected clients vector
                } else {
                    break;                                                      // Break if issue in server connnectivity
                }

            }
        } catch (Exception e) {
        }
    }

    // Method to send messages to the intended receipients based on the message sending type they provided in Client GUI
    public void sendMessageBasedOnMessageType(String user, String message) {

        if (MESSAGE_TYPE.equals("Unicast")) {

            for (HandleClient c : clients) {
                if (c.getUserName().equalsIgnoreCase(user)
                        || c.getUserName().equalsIgnoreCase(UNICAST_USERNAME)) {        //if message_type is unicast then send message to intended receiver if online
                    c.sendMessage(user, message);
                }
            }

        } else if (MESSAGE_TYPE.equals("Multicast")) {

            for (HandleClient c : clients) {
                if (c.getUserName().equalsIgnoreCase(user)) {
                    c.sendMessage(user, message);
                }
            }

            for (HandleClient c : clients) {

                for (int i = 0; i < MULTICAST_USERNAMES.size(); i++) {
                    if (c.getUserName().equalsIgnoreCase(MULTICAST_USERNAMES.get(i))) { //if message_type is multicast then send message to intended receivers who are online
                        c.sendMessage(user, message);
                    }
                }
            }

        } else if (MESSAGE_TYPE.equals("Broadcast")) {
            for (HandleClient c : clients) {
                c.sendMessage(user, message);                                           //if message_type is multicast then send message to all online users
            }
        }
    }

    private void broadcastUpdateUserList() {
        for (HandleClient c : clients) {
            c.sendMessageToUpdateUserList(Constants.MESSAGE_TO_UPDATE_USER_LIST);       //send a broadcast message to all clients to update the userLog
        }
    }

    private void broadcastToCloseAllConnectedClients() {
        for (HandleClient c : clients) {
            c.sendMessageToCloseAllConnectedClients(Constants.MESSAGE_TO_CLOSE_ALL_CONNECTED_CLIENTS);  //send a broadcast message to disconnect all the clients
        }
    }

    // Class to handle multiple client threads
    class HandleClient extends Thread {

        String name = "";
        BufferedReader input;
        PrintWriter output;

        public HandleClient(Socket client) throws Exception {
            // get input and output streams
            input = new BufferedReader(new InputStreamReader(client.getInputStream()));
            output = new PrintWriter(client.getOutputStream(), true);

            name = input.readLine();    // read name
            users.add(name);            // add to vector
            refreshListOfUsers();       // refresh the userLog
            start();                    // start the thread
            broadcastUpdateUserList();  // send a broadcast message to all clients to update the userLog

        }

        //method for sending a message to update the userLog
        public void sendMessageToUpdateUserList(String msg) {
            output.println(msg);
        }

        //method for sending a message to disconnect all clients
        public void sendMessageToCloseAllConnectedClients(String msg) {
            editCSVBeforeClosingServer();
            output.println(msg);
        }

        //method for sending a chat message to intended recipient
        public void sendMessage(String uname, String msg) {
            output.println(uname + ":" + msg);
        }

        //method to get username of connected client
        public String getUserName() {
            return name;
        }

        public void run() {
            String line;
            try {
                while (true) {

                    line = input.readLine();    // read message sent by client

                    splitMessageStream(line);   // split the message to identify different attributes of the message (Attributes: Message, MessageType, Receiver)

                    if (MESSAGE.equals(Constants.MESSAGE_TO_CLOSE_CLIENT)) {                // check if the message contains Specific Text to close and remove client
                        //System.out.println("Removing client from live connnection : ");

                        clients.remove(this);       // remove the user from client handler thread list
                        users.remove(name);         // remove the username from active users list

                        refreshListOfUsers();       // refresh the userLog
                        broadcastUpdateUserList();  // send a broadcast message to all clients to update the userLog

                        break;
                    } else {
                        sendMessageBasedOnMessageType(name, MESSAGE); // send chat-message to the intended receivers based on the message type specified by sender
                    }
                }
            } catch (Exception ex) {
                System.out.println(ex.getMessage());
            }
        }
    }

    // Method to split input message based on pre-defined keyword (to get message attributes)
    private void splitMessageStream(String line) {

        if (line.contains(Constants.MESSAGE_SPLITTER_KEYWORD)) {                // check if the input message contains the predefined keyword for splitting the message
            String[] parts = line.split(Constants.MESSAGE_SPLITTER_KEYWORD);    // split the message on the basis of predefined keyword

            MESSAGE = parts[0];                                                 // store 0th element of array as String "message"
            MESSAGE_TYPE = parts[1];                                            // store 1st element of array as String "message_type"

            if (MESSAGE_TYPE.equals("Unicast")) {
                UNICAST_USERNAME = parts[2];                                    // store 2nd element of array as String "username" for unicast
            } else if (MESSAGE_TYPE.equals("Multicast")) {
                MULTICAST_USERNAMES.clear();

                MULTICAST_USERLIST = parts[2];                                  // store 2nd element of array as String "list of usernames" for multicast

                String[] userParts = MULTICAST_USERLIST.split(",");             // split the String "list of usernames" for multicast based on comma ","

                for (int i = 0; i < userParts.length; i++) {
                    MULTICAST_USERNAMES.add(userParts[i].trim());               // add all the usernames to an ArrayList multicast_usernames
                }
            }
        } else {
            MESSAGE = line;                                                     // if no predefined keyword found for splitting the input message, then store input message as String "message"
        }

    }

    // Method to refresh the JTextArea showing userLog information
    private void refreshListOfUsers() {
        // clear all JTextArea before updating new values
        username_ta.setText("");
        status_ta.setText("");
        timestamp_ta.setText("");

        // read latest userLog available in CSV file
        CSVReaderInJava.readUsersFromCSV(Constants.CSV_FILEPATH + "\\" + Constants.CSV_FILENAME);

        // append each record from CSV file to particular JTextArea
        for (int i = 0; i < CSVReaderInJava.users.size(); i++) {

            username_ta.append(CSVReaderInJava.users.get(i).getUsername() + "\n\n");
            status_ta.append(CSVReaderInJava.users.get(i).getStatus() + "\n\n");
            timestamp_ta.append(CSVReaderInJava.users.get(i).getTimestamp() + "\n\n");
        }

    }

    // Method to save all user data in CSV before closing the active server
    private void editCSVBeforeClosingServer() {

        // read latest userLog available in CSV file
        CSVReaderInJava.readUsersFromCSV(Constants.CSV_FILEPATH + "\\" + Constants.CSV_FILENAME);

        // loop to iterate all usernames present in the CSV file
        for (int i = 0; i < CSVReaderInJava.users.size(); i++) {
            if (CSVReaderInJava.users.get(i).getStatus().equalsIgnoreCase(Constants.STATUS.ONLINE)) {    // if user status is online then

                // Store the details of each user in a CSV file
                String timestamp = Utils.getDateAndTimeFromTimeStamp(System.currentTimeMillis(), Constants.DATE_FORMAT_FULL_DATE_TIME);
                CSVReaderInJava.users.get(i).setTimestamp(timestamp);
                CSVReaderInJava.users.get(i).setStatus(Constants.STATUS.OFFLINE);
            }
        }

        rewriteCSV();
    }

    // Method to rewrite CSV File
    private void rewriteCSV() {
        List<String[]> users = new ArrayList<String[]>();
        for (int j = 0; j < CSVReaderInJava.users.size(); j++) {
            users.add(new String[]{CSVReaderInJava.users.get(j).getUsername(), CSVReaderInJava.users.get(j).getTimestamp(), CSVReaderInJava.users.get(j).getStatus()});
        }
        Utils.writeDataAtOnce(users);
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton close_server_btn;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JTextArea status_ta;
    private javax.swing.JTextArea timestamp_ta;
    private javax.swing.JScrollPane userListScrollPane;
    private javax.swing.JTextArea username_ta;
    // End of variables declaration//GEN-END:variables

}
